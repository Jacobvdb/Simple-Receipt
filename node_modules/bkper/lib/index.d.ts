/**
 * Bkper REST API Node client.
 *
 * Learn more at https://bkper.com/docs
 *
 * @packageDocumentation
 */

/// <reference types="bkper-api-types" />

/**
 *
 * This class defines an [Account](https://en.wikipedia.org/wiki/Account_(bookkeeping)) of a [[Book]].
 *
 * It mantains a balance of all amount [credited and debited](http://en.wikipedia.org/wiki/Debits_and_credits) in it by [[Transactions]].
 *
 * An Account can be grouped by [[Groups]].
 *
 * @public
 */
export declare class Account {
    
    
    
    /**
     * Gets the account internal id.
     */
    getId(): string;
    /**
     * Gets the account name.
     */
    getName(): string;
    /**
     *
     * Sets the name of the Account.
     *
     * @returns This Account, for chainning.
     */
    setName(name: string): Account;
    /**
     * @returns The name of this account without spaces or special characters.
     */
    getNormalizedName(): string;
    /**
     * @returns The type for of this account.
     */
    getType(): AccountType;
    /**
     *
     * Sets the type of the Account.
     *
     * @returns This Account, for chainning
     */
    setType(type: AccountType): Account;
    /**
     * Gets the custom properties stored in this Account.
     */
    getProperties(): {
        [key: string]: string;
    };
    /**
     * Sets the custom properties of the Account
     *
     * @param properties - Object with key/value pair properties
     *
     * @returns This Account, for chainning.
     */
    setProperties(properties: {
        [key: string]: string;
    }): Account;
    /**
     * Gets the property value for given keys. First property found will be retrieved
     *
     * @param keys - The property key
     */
    getProperty(...keys: string[]): string;
    /**
     * Sets a custom property in the Account.
     *
     * @param key - The property key
     * @param value - The property value
     *
     * @returns This Account, for chainning.
     */
    setProperty(key: string, value: string): Account;
    /**
     * Delete a custom property
     *
     * @param key - The property key
     *
     * @returns This Account, for chainning.
     */
    deleteProperty(key: string): Account;
    /**
     * Gets the balance based on credit nature of this Account.
     *
     * @param raw - True to get the raw balance, no matter the credit nature of this Account.
     *
     * @returns The balance of this account.
     */
    getBalance(raw?: boolean): Amount;
    /**
     * Gets the raw balance, no matter credit nature of this Account.
     *
     * @returns The balance of this account.
     */
    getBalanceRaw(): Amount;
    /**
     * Tell if this account is archived.
     */
    isArchived(): boolean;
    /**
     * Set account archived/unarchived.
     *
     * @returns This Account, for chainning.
     */
    setArchived(archived: boolean): Account;
    /**
     * Tell if the Account has any transaction already posted.
     *
     * Accounts with transaction posted, even with zero balance, can only be archived.
     */
    hasTransactionPosted(): boolean;
    /**
     *
     * Tell if the account is permanent.
     *
     * Permanent Accounts are the ones which final balance is relevant and keep its balances over time.
     *
     * They are also called [Real Accounts](http://en.wikipedia.org/wiki/Account_(accountancy)#Based_on_periodicity_of_flow)
     *
     * Usually represents assets or tangibles, capable of being perceived by the senses or the mind, like bank accounts, money, debts and so on.
     *
     * @returns True if its a permanent Account
     */
    isPermanent(): boolean;
    /**
     * Tell if the account has a Credit nature or Debit otherwise
     *
     * Credit accounts are just for representation purposes. It increase or decrease the absolute balance. It doesn't affect the overall balance or the behavior of the system.
     *
     * The absolute balance of credit accounts increase when it participate as a credit/origin in a transaction. Its usually for Accounts that increase the balance of the assets, like revenue accounts.
     *
     * ```
     *         Crediting a credit
     *   Thus ---------------------> account increases its absolute balance
     *         Debiting a debit
     *
     *
     *         Debiting a credit
     *   Thus ---------------------> account decreases its absolute balance
     *         Crediting a debit
     * ```
     *
     * As a rule of thumb, and for simple understanding, almost all accounts are Debit nature (NOT credit), except the ones that "offers" amount for the books, like revenue accounts.
     */
    isCredit(): boolean;
    /**
     * Get the [[Groups]] of this account.
     */
    getGroups(): Promise<Set<Group>>;
    /**
     * Sets the groups of the Account.
     *
     * @returns This Account, for chainning.
     */
    setGroups(groups: string[] | Group[]): Account;
    /**
     * Add a group to the Account.
     *
     * @returns This Account, for chainning.
     */
    addGroup(group: string | Group): Promise<Account>;
    /**
     * Remove a group from the Account.
     */
    removeGroup(group: string | Group): Promise<Account>;
    /**
     * Tell if this account is in the [[Group]]
     *
     * @param  group - The Group name, id or object
     */
    isInGroup(group: string | Group): Promise<boolean>;
    
    /**
     * Perform create new account.
     */
    create(): Promise<Account>;
    /**
     * Perform update account, applying pending changes.
     */
    update(): Promise<Account>;
    /**
     * Perform delete account.
     */
    remove(): Promise<Account>;
}

/**
 * Enum that represents account types.
 *
 * @public
 */
export declare enum AccountType {
    /**
     * Asset account type
     */
    ASSET = "ASSET",
    /**
     * Liability account type
     */
    LIABILITY = "LIABILITY",
    /**
     * Incoming account type
     */
    INCOMING = "INCOMING",
    /**
     * Outgoing account type
     */
    OUTGOING = "OUTGOING"
}

/**
 * This class defines an Amount for arbitrary-precision decimal arithmetic.
 *
 * It inherits methods from [big.js](http://mikemcl.github.io/big.js/) library
 *
 * @public
 */
export declare class Amount {
    
    /**
     * The Amount constructor.
     */
    constructor(n: number | string | Amount);
    /**
     * Returns an absolute Amount.
     */
    abs(): Amount;
    /**
     * Compare
     */
    cmp(n: number | string | Amount): -1 | 0 | 1;
    /**
     * Divide by
     */
    div(n: number | string | Amount): Amount;
    /**
     * Equals to
     */
    eq(n: number | string | Amount): boolean;
    /**
     * Greater than
     */
    gt(n: number | string | Amount): boolean;
    /**
     * Greater than or equal
     */
    gte(n: number | string | Amount): boolean;
    /**
     * Less than
     */
    lt(n: number | string | Amount): boolean;
    /**
     * Less than or equal to
     */
    lte(n: number | string | Amount): boolean;
    /**
     * Sum
     */
    plus(n: number | string | Amount): Amount;
    /**
     * Minus
     */
    minus(n: number | string | Amount): Amount;
    /**
     * Modulo - the integer remainder of dividing this Amount by n.
     *
     * Similar to % operator
     *
     */
    mod(n: number | string | Amount): Amount;
    /**
     * Round to a maximum of dp decimal places.
     */
    round(dp?: number): Amount;
    /**
     * Multiply
     */
    times(n: number | string | Amount): Amount;
    /**
     * Returns a string representing the value of this Amount in normal notation to a fixed number of decimal places dp.
     */
    toFixed(dp?: number): string;
    /**
     * Returns a string representing the value of this Amount.
     */
    toString(): string;
    /**
     * Returns a primitive number representing the value of this Amount.
     */
    toNumber(): number;
    
    
    
}

/**
 * Defines an App on Bkper.
 *
 * Apps can be installed on Books by users.s
 *
 * @public
 */
export declare class App {
    
    
    /**
     *
     * Sets the webhook url for development.
     *
     * @returns This App, for chainning.
     */
    setWebhookUrlDev(webhookUrlDev: string): App;
    /**
     * Partially update an App, applying pending changes.
     */
    patch(): Promise<App>;
    
    
    
    
    
    
    
    
}

/**
 * Enum that represents balance types.
 *
 * @public
 */
export declare enum BalanceType {
    /**
     * Total balance
     */
    TOTAL = "TOTAL",
    /**
     * Period balance
     */
    PERIOD = "PERIOD",
    /**
     * Cumulative balance
     */
    CUMULATIVE = "CUMULATIVE"
}

/**
 * This is the main Entry Point of the [bkper-node](https://www.npmjs.com/package/bkper) library.
 *
 * @public
 */
export declare class Bkper {
    /**
     * Gets the [[Book]] with the specified bookId from url param.
     *
     * @param id - The universal book id - The same bookId param of URL you access at app.bkper.com
     *
     */
    static getBook(id: string): Promise<Book>;
    /**
     * Sets the API key to identify the agent.
     *
     * API keys are intended for agent identification only, not for authentication. [Learn more](https://cloud.google.com/endpoints/docs/frameworks/java/when-why-api-key)
     *
     * See how to create your api key [here](https://cloud.google.com/docs/authentication/api-keys).
     *
     * @param key - The key from GCP API & Services Credentials console.
     *
     */
    static setApiKey(key: string): App;
    /**
     * Sets the [[OAuthTokenProvider]].
     *
     * OAuthTokenProvider issue a valid OAuth token upon calling the Bkper Rest API.
     *
     * @param oauthTokenProvider - The [[OAuthTokenProvider]] implementation.
     *
     */
    static setOAuthTokenProvider(oauthTokenProvider: OAuthTokenProvider): Promise<void>;
}

/**
 *
 * A Book represents [General Ledger](https://en.wikipedia.org/wiki/General_ledger) for a company or business, but can also represent a [Ledger](https://en.wikipedia.org/wiki/Ledger) for a project or department
 *
 * It contains all [[Accounts]] where [[Transactions]] are recorded/posted;
 *
 * @public
 */
export declare class Book {
    
    
    
    
    
    
    
    /**
     * Same as bookId param
     */
    getId(): string;
    /**
     * @returns The name of this Book
     */
    getName(): string;
    /**
     *
     * Sets the name of the Book.
     *
     * @returns This Book, for chainning.
     */
    setName(name: string): Book;
    /**
     * @returns The number of fraction digits supported by this Book. Same as getDecimalPlaces
     */
    getFractionDigits(): number;
    /**
     * @returns The number of decimal places supported by this Book. Same as getFractionDigits
     */
    getDecimalPlaces(): number;
    /**
     *
     * Sets the number of fraction digits (decimal places) supported by this Book
     *
     * @returns This Book, for chainning.
     */
    setFractionDigits(fractionDigits: number): Book;
    /**
     * @returns The period slice for balances visualization
     */
    getPeriod(): Period;
    /**
     * Sets the period slice for balances visualization
     *
     * @returns This Book, for chainning.
     */
    setPeriod(period: Period): Book;
    /**
     * @returns The start month when YEAR period set
     */
    getPeriodStartMonth(): Month;
    /**
     * Sets the start month when YEAR period set
     *
     * @returns This Book, for chainning.
     */
    setPeriodStartMonth(month: Month): Book;
    /**
     * @returns The transactions pagination page size
     */
    getPageSize(): number;
    /**
     * Sets the transactions pagination page size
     *
     * @returns This Book, for chainning.
     */
    setPageSize(pageSize: number): Book;
    /**
     * @returns The name of the owner of the Book
     */
    getOwnerName(): string;
    /**
     * @returns The permission for the current user
     */
    getPermission(): Permission;
    /**
     * @returns The collection of this book
     */
    getCollection(): Collection;
    /**
     * @returns The date pattern of the Book. Current: dd/MM/yyyy | MM/dd/yyyy | yyyy/MM/dd
     */
    getDatePattern(): string;
    /**
     *
     * Sets the date pattern of the Book. Current: dd/MM/yyyy | MM/dd/yyyy | yyyy/MM/dd
     *
     * @returns This Book, for chainning.
     */
    setDatePattern(datePattern: string): Book;
    /**
     * @returns The lock date of the Book in ISO format yyyy-MM-dd
     */
    getLockDate(): string;
    /**
     *
     * Sets the lock date of the Book in ISO format yyyy-MM-dd.
     *
     * @returns This Book, for chainning.
     */
    setLockDate(lockDate: string): Book;
    /**
     * @returns The decimal separator of the Book
     */
    getDecimalSeparator(): DecimalSeparator;
    /**
     *
     * Sets the decimal separator of the Book
     *
     * @returns This Book, for chainning.
     */
    setDecimalSeparator(decimalSeparator: DecimalSeparator): Book;
    /**
     * @returns The time zone of the Book
     */
    getTimeZone(): string;
    /**
     *
     * Sets the time zone of the Book
     *
     * @returns This Book, for chainning.
     */
    setTimeZone(timeZone: string): Book;
    /**
     * @returns The time zone offset of the book, in minutes
     */
    getTimeZoneOffset(): number;
    /**
     * @returns The last update date of the book, in in milliseconds
     */
    getLastUpdateMs(): number;
    /**
     * Gets the custom properties stored in this Book
     */
    getProperties(): {
        [key: string]: string;
    };
    /**
     * Gets the property value for given keys. First property found will be retrieved
     *
     * @param keys - The property key
     */
    getProperty(...keys: string[]): string;
    /**
     * Sets the custom properties of the Book
     *
     * @param properties - Object with key/value pair properties
     *
     * @returns This Book, for chainning.
     */
    setProperties(properties: {
        [key: string]: string;
    }): Book;
    /**
     * Sets a custom property in the Book.
     *
     * @param key - The property key
     * @param value - The property value
     *
     * @returns This Book, for chainning.
     */
    setProperty(key: string, value: string): Book;
    /**
     * Formats a date according to date pattern of the Book.
     *
     * @param date - The date to format as string.
     * @param timeZone - The output timezone of the result. Default to script's timeZone
     *
     * @returns The date formated
     */
    formatDate(date: Date, timeZone?: string): string;
    /**
     * Formats a value according to [[DecimalSeparator]] and fraction digits of the Book.
     *
     * @param value - The value to be formatted.
     *
     * @returns The value formated
     */
    formatValue(value: Amount | number): string;
    /**
     * Parse a value string according to [[DecimalSeparator]] and fraction digits of the Book.
     */
    parseValue(value: string): Amount;
    /**
     * Rounds a value according to the number of fraction digits of the Book
     *
     * @param value - The value to be rounded
     *
     * @returns The value rounded
     */
    round(value: Amount | number): Amount;
    /**
     * Create [[Transactions]] on the Book, in batch.
     */
    batchCreateTransactions(transactions: Transaction[]): Promise<Transaction[]>;
    /**
     * Trigger [Balances Audit](https://help.bkper.com/en/articles/4412038-balances-audit) async process.
     */
    audit(): void;
    /**
     * Resumes a transaction iteration using a continuation token from a previous iterator.
     *
     * @param continuationToken - continuation token from a previous transaction iterator
     *
     * @returns a collection of transactions that remained in a previous iterator when the continuation token was generated
     */
    continueTransactionIterator(query: string, continuationToken: string): TransactionIterator;
    configureTransactions_(transactions: Transaction[]): Transaction[];
    
    /**
     * Instantiate a new [[Transaction]]
     *
     * Example:
     *
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * book.newTransaction()
     *  .setDate('2013-01-25')
     *  .setDescription("Filling tank of my truck")
     *  .from('Credit Card')
     *  .to('Gas')
     *  .setAmount(126.50)
     *  .create();
     *
     * ```
     *
     */
    newTransaction(): Transaction;
    /**
     * Instantiate a new [[Account]]
     *
     * Example:
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * book.newAccount()
     *  .setName('Some New Account')
     *  .setType('INCOMING')
     *  .addGroup('Revenue').addGroup('Salary')
     *  .setProperties({prop_a: 'A', prop_b: 'B'})
     *  .create();
     * ```
     */
    newAccount(): Account;
    /**
     * Instantiate a new [[Group]]
     *
     * Example:
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * book.newGroup()
     *  .setName('Some New Group')
     *  .setProperty('key', 'value')
     *  .create();
     * ```
     */
    newGroup(): Group;
    /**
     * Gets an [[Account]] object
     *
     * @param idOrName - The id or name of the Account
     *
     * @returns The matching Account object
     */
    getAccount(idOrName: string): Promise<Account>;
    
    removeGroupCache(group: Group): void;
    /**
     * Gets a [[Group]] object
     *
     * @param idOrName - The id or name of the Group
     *
     * @returns The matching Group object
     */
    getGroup(idOrName: string): Promise<Group>;
    /**
     * Gets all [[Groups]] of this Book
     */
    getGroups(): Promise<Group[]>;
    /**
     * Get Book transactions based on a query.
     *
     * See [Query Guide](https://help.bkper.com/en/articles/2569178-search-query-guide) to learn more
     *
     * @param query - The query string.
     *
     * @returns The Transactions result as an iterator.
     *
     * Example:
     *
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * var transactions = book.getTransactions("account:CreditCard after:28/01/2013 before:29/01/2013");
     *
     * while (transactions.hasNext()) {
     *  var transaction = transactions.next();
     *  Logger.log(transaction.getDescription());
     * }
     * ```
     */
    getTransactions(query?: string): TransactionIterator;
    /**
     * Retrieve a transaction by id
     */
    getTransaction(id: string): Promise<Transaction>;
    /**
     * Instantiate a new [[BkperFile]]
     *
     * Example:
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * book.newFile()
     *  .setBlob(UrlFetchApp.fetch('https://bkper.com/images/index/integrations4.png').getBlob())
     *  .create();
     * ```
     */
    newFile(): File;
    /**
     * Retrieve a file by id
     */
    getFile(id: string): Promise<File>;
    /**
     * Perform update Book, applying pending changes.
     */
    update(): Promise<Book>;
}

/**
 * This class defines a Collection of [[Books]].
 *
 * @public
 */
export declare class Collection {
    
    
    /**
     * @returns The id of this Collection
     */
    getId(): string;
    /**
     * @returns The name of this Collection
     */
    getName(): string;
    /**
     * @returns All Books of this collection.
     */
    getBooks(): Book[];
}

/**
 * Decimal separator of numbers on book
 *
 * @public
 */
export declare enum DecimalSeparator {
    /**
     * ,
     */
    COMMA = "COMMA",
    /**
     * .
     */
    DOT = "DOT"
}

/**
 *
 * This class defines a File uploaded to a [[Book]].
 *
 * A File can be attached to a [[Transaction]] or used to import data.
 *
 * @public
 */
export declare class File {
    
    
    /**
     * Gets the File id
     */
    getId(): string;
    /**
     * Gets the File name
     */
    getName(): string;
    /**
     *
     * Sets the name of the File.
     *
     * @returns This File, for chainning.
     */
    setName(name: string): File;
    /**
     * Gets the File content type
     */
    getContentType(): string;
    /**
     *
     * Sets the File content type.
     *
     * @returns This File, for chainning.
     */
    setContentType(contentType: string): File;
    /**
     * Gets the file content Base64 encoded
     */
    getContent(): Promise<string>;
    /**
     *
     * Sets the File content Base64 encoded.
     *
     * @returns This File, for chainning.
     */
    setContent(content: string): File;
    /**
     * Gets the file serving url for accessing via browser
     */
    getUrl(): string;
    /**
     * Gets the file size in bytes
     */
    getSize(): number;
    /**
     * Perform create new File.
     */
    create(): Promise<File>;
}

/**
 * This class defines a Group of [[Accounts]].
 *
 * Accounts can be grouped by different meaning, like Expenses, Revenue, Assets, Liabilities and so on
 *
 * Its useful to keep organized and for high level analysis.
 *
 * @public
 */
export declare class Group {
    
    accounts: Set<Account>;
    
    /**
     * @returns The id of this Group
     */
    getId(): string;
    /**
     * @returns The parent Group
     */
    getParent(): Promise<Group>;
    /**
     * Sets the parent Group.
     *
     * @returns This Group, for chainning.
     */
    setParent(group: Group): Group;
    /**
     * @returns The name of this Group
     */
    getName(): string;
    /**
     * Sets the name of the Group.
     *
     * @returns This Group, for chainning.
     */
    setName(name: string): Group;
    /**
     * @returns The name of this group without spaces and special characters
     */
    getNormalizedName(): string;
    /**
     * @returns All Accounts of this group.
     */
    getAccounts(): Promise<Account[]>;
    /**
     * @returns True if this group has any account in it
     */
    hasAccounts(): boolean;
    /**
     * @returns The type for of the accounts of this group. Null if mixed
     */
    getType(): AccountType;
    /**
     * Gets the custom properties stored in this Group
     */
    getProperties(): {
        [key: string]: string;
    };
    /**
     * Sets the custom properties of the Group
     *
     * @param properties - Object with key/value pair properties
     *
     * @returns This Group, for chainning.
     */
    setProperties(properties: {
        [key: string]: string;
    }): Group;
    /**
     * Gets the property value for given keys. First property found will be retrieved
     *
     * @param keys - The property key
     */
    getProperty(...keys: string[]): string;
    /**
     * Sets a custom property in the Group.
     *
     * @param key - The property key
     * @param value - The property value
     */
    setProperty(key: string, value: string): Group;
    /**
     * Delete a custom property
     *
     * @param key - The property key
     *
     * @returns This Group, for chainning.
     */
    deleteProperty(key: string): Group;
    /**
     * Tell if the Group is hidden on main transactions menu
     */
    isHidden(): boolean;
    /**
     *  Hide/Show group on main menu.
     */
    setHidden(hidden: boolean): Group;
    /**
     * Perform create new group.
     */
    create(): Promise<Group>;
    /**
     * Perform update group, applying pending changes.
     */
    update(): Promise<Group>;
    /**
     * Perform delete group.
     */
    remove(): Promise<Group>;
}

/**
 * Enum that represents a Month.
 *
 * @public
 */
declare enum Month {
    JANUARY = "JANUARY",
    FEBRUARY = "FEBRUARY",
    MARCH = "MARCH",
    APRIL = "APRIL",
    MAY = "MAY",
    JUNE = "JUNE",
    JULY = "JULY",
    AUGUST = "AUGUST",
    SEPTEMBER = "SEPTEMBER",
    OCTOBER = "OCTOBER",
    NOVEMBER = "NOVEMBER",
    DECEMBER = "DECEMBER"
}

/**
 * Interface to provide OAuth2 tokens upon calling the API.
 *
 * @public
 */
export declare interface OAuthTokenProvider {
    /**
     * A valid OAuth2 access token with **https://www.googleapis.com/auth/userinfo.email** scope authorized.
     */
    (): Promise<string>;
}

/**
 * Enum that represents a period slice.
 *
 * @public
 */
declare enum Period {
    /**
     *  Monthly period
     */
    MONTH = "MONTH",
    /**
     * Quarterly period
     */
    QUARTER = "QUARTER",
    /**
     * Yearly period
     */
    YEAR = "YEAR"
}

/**
 * The Periodicity of the query. It may depend on the level of granularity you write the range params.
 *
 * @public
 */
export declare enum Periodicity {
    /**
     * Example: after:25/01/1983, before:04/03/2013, after:$d-30, before:$d, after:$d-15/$m
     */
    DAILY = "DAILY",
    /**
     * Example: after:jan/2013, before:mar/2013, after:$m-1, before:$m
     */
    MONTHLY = "MONTHLY",
    /**
     * Example: on:2013, after:2013, $y
     */
    YEARLY = "YEARLY"
}

/**
 * Enum representing permissions of user in the Book
 *
 * Learn more at [share article](https://help.bkper.com/en/articles/2569153-share-your-book-with-your-peers).
 *
 * @public
 */
export declare enum Permission {
    /**
     * No permission
     */
    NONE = "NONE",
    /**
     * View transactions, accounts and balances.
     */
    VIEWER = "VIEWER",
    /**
     * Record and delete drafts only. Useful to collect data only
     */
    RECORDER = "RECORDER",
    /**
     * View transactions, accounts, record and delete drafts
     */
    POSTER = "POSTER",
    /**
     * Manage accounts, transactions, book configuration and sharing
     */
    EDITOR = "EDITOR",
    /**
     * Manage everything, including book visibility and deletion. Only one owner per book.
     */
    OWNER = "OWNER"
}

/**
 *
 * This class defines a Transaction between [credit and debit](http://en.wikipedia.org/wiki/Debits_and_credits) [[Accounts]].
 *
 * A Transaction is the main entity on the [Double Entry](http://en.wikipedia.org/wiki/Double-entry_bookkeeping_system) [Bookkeeping](http://en.wikipedia.org/wiki/Bookkeeping) system.
 *
 * @public
 */
export declare class Transaction {
    
    creditAccount: Account;
    debitAccount: Account;
    
    /**
     * @returns The id of the Transaction.
     */
    getId(): string;
    /**
     * @returns The id of the agent that created this transaction
     */
    getAgentId(): string;
    /**
     * Remote ids are used to avoid duplication.
     *
     * @returns The remote ids of the Transaction.
     */
    getRemoteIds(): string[];
    /**
     * Add a remote id to the Transaction.
     *
     * @param remoteId - The remote id to add.
     *
     * @returns This Transaction, for chainning.
     */
    addRemoteId(remoteId: string): Transaction;
    /**
     * @returns True if transaction was already posted to the accounts. False if is still a Draft.
     */
    isPosted(): boolean;
    /**
     * @returns True if transaction is checked.
     */
    isChecked(): boolean;
    /**
     * @returns True if transaction is in trash.
     */
    isTrashed(): boolean;
    /**
     * @returns All #hashtags used on the transaction.
     */
    getTags(): string[];
    /**
     * @returns All urls of the transaction.
     */
    getUrls(): string[];
    /**
     * Sets the Transaction urls. Url starts with https://
     *
     * @param urls - The urls array.
     *
     * @returns This Transaction, for chainning.
     */
    setUrls(urls: string[]): Transaction;
    /**
     * Add a url to the Transaction. Url starts with https://
     *
     * @param url - The url to add.
     *
     * @returns This Transaction, for chainning.
     */
    addUrl(url: string): Transaction;
    /**
     * @returns The files attached to the transaction.
     */
    getFiles(): File[];
    /**
     *
     * Adds a file attachment to the Transaction.
     *
     * Files not previously created in the Book will be automatically created.
     *
     * @param file - The file to add
     *
     * @returns This Transaction, for chainning.
     */
    addFile(file: File): Promise<Transaction>;
    /**
     * Check if the transaction has the specified tag.
     */
    hasTag(tag: string): boolean;
    /**
     * Gets the custom properties stored in this Transaction.
     */
    getProperties(): {
        [key: string]: string;
    };
    /**
     * Sets the custom properties of the Transaction
     *
     * @param properties - Object with key/value pair properties
     *
     * @returns This Transaction, for chainning.
     */
    setProperties(properties: {
        [key: string]: string;
    }): Transaction;
    /**
     * Gets the property value for given keys. First property found will be retrieved
     *
     * @param keys - The property key
     */
    getProperty(...keys: string[]): string;
    /**
    * Gets the custom properties keys stored in this Transaction.
    */
    getPropertyKeys(): string[];
    /**
     * Sets a custom property in the Transaction.
     *
     * @param key - The property key
     * @param value - The property value
     *
     * @returns This Transaction, for chainning.
     */
    setProperty(key: string, value: string): Transaction;
    /**
     * Delete a custom property
     *
     * @param key - The property key
     *
     * @returns This Transaction, for chainning.
     */
    deleteProperty(key: string): Transaction;
    /**
     * @returns The credit account. The same as origin account.
     */
    getCreditAccount(): Promise<Account>;
    /**
     * @returns The credit account name.
     */
    getCreditAccountName(): Promise<string>;
    /**
     *
     * Sets the credit/origin Account of the Transaction. Same as from().
     *
     * @param account - Account id, name or object.
     *
     * @returns This Transaction, for chainning.
     */
    setCreditAccount(account: Account): Transaction;
    /**
     *
     * Sets the credit/origin Account of the Transaction. Same as setCreditAccount().
     *
     * @param account - Account id, name or object.
     *
     * @returns This Transaction, for chainning.
     */
    from(account: Account): Transaction;
    /**
     * @returns The debit account. The same as destination account.
     *
     */
    getDebitAccount(): Promise<Account>;
    /**
     * @returns The debit account name.
     */
    getDebitAccountName(): Promise<string>;
    /**
     *
     * Sets the debit/origin Account of the Transaction. Same as to().
     *
     * @param account - Account id, name or object.
     *
     * @returns This Transaction, for chainning.
     */
    setDebitAccount(account: Account): Transaction;
    /**
     *
     * Sets the debit/origin Account of the Transaction. Same as setDebitAccount().
     *
     * @param account - Account id, name or object.
     *
     * @returns This Transaction, for chainning.
     */
    to(account: Account): Transaction;
    /**
     * @returns The amount of the transaction.
     */
    getAmount(): Amount;
    /**
     *
     * Sets the amount of the Transaction.
     *
     * @returns This Transaction, for chainning.
     */
    setAmount(amount: Amount | number | string): Transaction;
    /**
     * Get the absolute amount of this transaction if the given account is at the credit side, else null.
     *
     * @param account - The account object, id or name.
     */
    getCreditAmount(account: Account | string): Promise<Amount>;
    /**
     * Gets the absolute amount of this transaction if the given account is at the debit side, else null.
     *
     * @param account - The account object, id or name.
     */
    getDebitAmount(account: Account | string): Promise<Amount>;
    /**
     * Gets the [[Account]] at the other side of the transaction given the one in one side.
     *
     * @param account - The account object, id or name.
     */
    getOtherAccount(account: Account | string): Promise<Account>;
    /**
     *
     * The account name at the other side of the transaction given the one in one side.
     *
     * @param account - The account object, id or name.
     */
    getOtherAccountName(account: string | Account): Promise<string>;
    /**
     *
     * Tell if the given account is credit on the transaction
     *
     * @param account - The account object
     */
    isCredit(account: Account): Promise<boolean>;
    /**
     *
     * Tell if the given account is debit on the transaction
     *
     * @param account - The account object
     */
    isDebit(account: Account): Promise<boolean>;
    
    /**
     * @returns The description of this transaction.
     */
    getDescription(): string;
    /**
     *
     * Sets the description of the Transaction.
     *
     * @returns This Transaction, for chainning.
     */
    setDescription(description: string): Transaction;
    /**
     * @returns The Transaction date, in ISO format yyyy-MM-dd.
     */
    getDate(): string;
    /**
     *
     * Sets the date of the Transaction.
     *
     * @returns This Transaction, for chainning
     */
    setDate(date: string | Date): Transaction;
    /**
     * @returns The Transaction Date object, on the time zone of the [[Book]].
     */
    getDateObject(): Date;
    /**
     * @returns The Transaction date number, in format YYYYMMDD.
     */
    getDateValue(): number;
    /**
     * @returns The Transaction date, formatted on the date pattern of the [[Book]].
     */
    getDateFormatted(): string;
    /**
     * @returns The date the transaction was created.
     */
    getCreatedAt(): Date;
    /**
     * @returns The date the transaction was created, formatted according to the date pattern of [[Book]].
     */
    getCreatedAtFormatted(): string;
    
    
    /**
     * Gets the balance that the [[Account]] has at that day, when listing transactions of that Account.
     *
     * Evolved balances is returned when searching for transactions of a permanent [[Account]].
     *
     * Only comes with the last posted transaction of the day.
     *
     * @param raw - True to get the raw balance, no matter the credit nature of the [[Account]].
     */
    getAccountBalance(raw?: boolean): Promise<Amount>;
    /**
     * Perform create new draft transaction.
     */
    create(): Promise<Transaction>;
    /**
     * Upddate transaction, applying pending changes.
     */
    update(): Promise<Transaction>;
    /**
     * Perform check transaction.
     */
    check(): Promise<Transaction>;
    /**
     * Perform uncheck transaction.
     */
    uncheck(): Promise<Transaction>;
    /**
     * Perform post transaction, changing credit and debit [[Account]] balances.
     */
    post(): Promise<Transaction>;
    /**
     * Remove the transaction, sending to trash.
     */
    remove(): Promise<Transaction>;
    /**
     * Restore the transaction from trash.
     */
    restore(): Promise<Transaction>;
}

/**
 *
 * An iterator that allows scripts to iterate over a potentially large collection of transactions.
 *
 * Example:
 *
 * ```js
 * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
 *
 * var transactionIterator = book.getTransactions("account:CreditCard after:28/01/2013 before:29/01/2013");
 *
 * while (transactionIterator.hasNext()) {
 *  var transaction = transactions.next();
 *  Logger.log(transaction.getDescription());
 * }
 * ```
 *
 * @public
 */
export declare class TransactionIterator {
    
    
    
    
    
    
    /**
     * Gets the Book that originate the iterator
     */
    getBook(): Book;
    /**
     * Gets a token that can be used to resume this iteration at a later time.
     *
     * This method is useful if processing an iterator in one execution would exceed the maximum execution time.
     *
     * Continuation tokens are generally valid short period of time.
     */
    getContinuationToken(): string;
    /**
     * Sets a continuation token from previous paused iteration
     */
    setContinuationToken(continuationToken: string): Promise<void>;
    /**
     * Determines whether calling next() will return a transaction.
     */
    hasNext(): Promise<boolean>;
    /**
     * Gets the next transaction in the collection of transactions.
     */
    next(): Promise<Transaction>;
    /**
     * @returns The account, when filtering by a single account.
     */
    getAccount(): Promise<Account>;
}

export { }
