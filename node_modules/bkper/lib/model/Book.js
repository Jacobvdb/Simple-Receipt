"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Book = void 0;
const AccountService = __importStar(require("../service/account-service"));
const GroupService = __importStar(require("../service/group-service"));
const BookService = __importStar(require("../service/book-service"));
const FileService = __importStar(require("../service/file-service"));
const TransactionService = __importStar(require("../service/transaction-service"));
const IntegrationService = __importStar(require("../service/integration-service"));
const Utils = __importStar(require("../utils"));
const utils_1 = require("../utils");
const Account_1 = require("./Account");
const Collection_1 = require("./Collection");
const File_1 = require("./File");
const Group_1 = require("./Group");
const Transaction_1 = require("./Transaction");
const TransactionIterator_1 = require("./TransactionIterator");
const Integration_1 = require("./Integration");
/**
 *
 * A Book represents [General Ledger](https://en.wikipedia.org/wiki/General_ledger) for a company or business, but can also represent a [Ledger](https://en.wikipedia.org/wiki/Ledger) for a project or department
 *
 * It contains all [[Accounts]] where [[Transactions]] are recorded/posted;
 *
 * @public
 */
class Book {
    constructor(json) {
        this.wrapped = json;
    }
    /**
     * @returns The wrapped plain json object
     */
    json() {
        return this.wrapped;
    }
    /**
     * Same as bookId param
     */
    getId() {
        return this.wrapped.id;
    }
    /**
     * @returns The name of this Book
     */
    getName() {
        return this.wrapped.name;
    }
    /**
     *
     * Sets the name of the Book.
     *
     * @returns This Book, for chainning.
     */
    setName(name) {
        this.wrapped.name = name;
        return this;
    }
    /**
     * @returns The number of fraction digits supported by this Book. Same as getDecimalPlaces
     */
    getFractionDigits() {
        return this.wrapped.fractionDigits;
    }
    /**
     * @returns The number of decimal places supported by this Book. Same as getFractionDigits
     */
    getDecimalPlaces() {
        return this.getFractionDigits();
    }
    /**
     *
     * Sets the number of fraction digits (decimal places) supported by this Book
     *
     * @returns This Book, for chainning.
     */
    setFractionDigits(fractionDigits) {
        this.wrapped.fractionDigits = fractionDigits;
        return this;
    }
    /**
     * @returns The period slice for balances visualization
     */
    getPeriod() {
        return this.wrapped.period;
    }
    /**
     * Sets the period slice for balances visualization
     *
     * @returns This Book, for chainning.
     */
    setPeriod(period) {
        this.wrapped.period = period;
        return this;
    }
    /**
     * @returns The start month when YEAR period set
     */
    getPeriodStartMonth() {
        return this.wrapped.periodStartMonth;
    }
    /**
     * Sets the start month when YEAR period set
     *
     * @returns This Book, for chainning.
     */
    setPeriodStartMonth(month) {
        this.wrapped.periodStartMonth = month;
        return this;
    }
    /**
     * @returns The transactions pagination page size
     */
    getPageSize() {
        return this.wrapped.pageSize;
    }
    /**
     * Sets the transactions pagination page size
     *
     * @returns This Book, for chainning.
     */
    setPageSize(pageSize) {
        this.wrapped.pageSize = pageSize;
        return this;
    }
    /**
     * @returns The name of the owner of the Book
     */
    getOwnerName() {
        return this.wrapped.ownerName;
    }
    /**
     * @returns The permission for the current user
     */
    getPermission() {
        return this.wrapped.permission;
    }
    /**
     * @returns The collection of this book
     */
    getCollection() {
        if (this.wrapped.collection != null && this.collection == null) {
            this.collection = new Collection_1.Collection(this.wrapped.collection);
        }
        return this.collection;
    }
    /**
     * @returns The date pattern of the Book. Current: dd/MM/yyyy | MM/dd/yyyy | yyyy/MM/dd
     */
    getDatePattern() {
        return this.wrapped.datePattern;
    }
    /**
     *
     * Sets the date pattern of the Book. Current: dd/MM/yyyy | MM/dd/yyyy | yyyy/MM/dd
     *
     * @returns This Book, for chainning.
     */
    setDatePattern(datePattern) {
        this.wrapped.datePattern = datePattern;
        return this;
    }
    /**
     * @returns The lock date of the Book in ISO format yyyy-MM-dd
     */
    getLockDate() {
        return this.wrapped.lockDate;
    }
    /**
     *
     * Sets the lock date of the Book in ISO format yyyy-MM-dd.
     *
     * @returns This Book, for chainning.
     */
    setLockDate(lockDate) {
        if (lockDate == null) {
            lockDate = "1900-00-00";
        }
        this.wrapped.lockDate = lockDate;
        return this;
    }
    /**
     * @returns The closing date of the Book in ISO format yyyy-MM-dd
     */
    getClosingDate() {
        return this.wrapped.closingDate;
    }
    /**
     *
     * Sets the closing date of the Book in ISO format yyyy-MM-dd.
     *
     * @returns This Book, for chainning.
     */
    setClosingDate(closingDate) {
        if (closingDate == null) {
            closingDate = "1900-00-00";
        }
        this.wrapped.closingDate = closingDate;
        return this;
    }
    /**
     * @returns The decimal separator of the Book
     */
    getDecimalSeparator() {
        return this.wrapped.decimalSeparator;
    }
    /**
     *
     * Sets the decimal separator of the Book
     *
     * @returns This Book, for chainning.
     */
    setDecimalSeparator(decimalSeparator) {
        this.wrapped.decimalSeparator = decimalSeparator;
        return this;
    }
    /**
     * @returns The time zone of the Book
     */
    getTimeZone() {
        return this.wrapped.timeZone;
    }
    /**
     *
     * Sets the time zone of the Book
     *
     * @returns This Book, for chainning.
     */
    setTimeZone(timeZone) {
        this.wrapped.timeZone = timeZone;
        return this;
    }
    /**
     * @returns The time zone offset of the book, in minutes
     */
    getTimeZoneOffset() {
        return this.wrapped.timeZoneOffset;
    }
    /**
     * @returns The last update date of the book, in in milliseconds
     */
    getLastUpdateMs() {
        return +this.wrapped.lastUpdateMs;
    }
    /**
     * Gets the custom properties stored in this Book
     */
    getProperties() {
        return this.wrapped.properties != null ? Object.assign({}, this.wrapped.properties) : {};
    }
    /**
     * Gets the property value for given keys. First property found will be retrieved
     *
     * @param keys - The property key
     */
    getProperty(...keys) {
        for (let index = 0; index < keys.length; index++) {
            const key = keys[index];
            let value = this.wrapped.properties != null ? this.wrapped.properties[key] : null;
            if (value != null && value.trim() != '') {
                return value;
            }
        }
        return null;
    }
    /**
     * Sets the custom properties of the Book
     *
     * @param properties - Object with key/value pair properties
     *
     * @returns This Book, for chainning.
     */
    setProperties(properties) {
        this.wrapped.properties = Object.assign({}, properties);
        return this;
    }
    /**
     * Sets a custom property in the Book.
     *
     * @param key - The property key
     * @param value - The property value
     *
     * @returns This Book, for chainning.
     */
    setProperty(key, value) {
        if (key == null || key.trim() == '') {
            return this;
        }
        if (this.wrapped.properties == null) {
            this.wrapped.properties = {};
        }
        this.wrapped.properties[key] = value;
        return this;
    }
    /**
     * Formats a date according to date pattern of the Book.
     *
     * @param date - The date to format as string.
     * @param timeZone - The output timezone of the result. Default to script's timeZone
     *
     * @returns The date formated
     */
    formatDate(date, timeZone) {
        if (timeZone == null || timeZone.trim() == "") {
            timeZone = this.getTimeZone();
        }
        return Utils.formatDate(date, this.getDatePattern(), timeZone);
    }
    /**
     * Parse a date string according to date pattern and timezone of the Book.
     *
     * Also parse ISO yyyy-mm-dd format.
     */
    parseDate(date) {
        return Utils.parseDate(date, this.getDatePattern(), this.getTimeZone());
    }
    /**
     * Formats a value according to [[DecimalSeparator]] and fraction digits of the Book.
     *
     * @param value - The value to be formatted.
     *
     * @returns The value formated
     */
    formatValue(value) {
        if (!value) {
            return '';
        }
        return Utils.formatValue(value, this.getDecimalSeparator(), this.getFractionDigits());
    }
    /**
     * Parse a value string according to [[DecimalSeparator]] and fraction digits of the Book.
     */
    parseValue(value) {
        return Utils.parseValue(value, this.getDecimalSeparator());
    }
    /**
     * Rounds a value according to the number of fraction digits of the Book
     *
     * @param value - The value to be rounded
     *
     * @returns The value rounded
     */
    round(value) {
        return Utils.round(value, this.getFractionDigits());
    }
    /**
     * Create [[Transactions]] on the Book, in batch.
     */
    batchCreateTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            let transactionPayloads = [];
            transactions.forEach(tx => transactionPayloads.push(tx.wrapped));
            transactionPayloads = yield TransactionService.createTransactionsBatch(this.getId(), transactionPayloads);
            transactions = Utils.wrapObjects(new Transaction_1.Transaction(), transactionPayloads);
            this.configureTransactions_(transactions);
            return transactions;
        });
    }
    /**
     * Trash [[Transactions]] on the Book, in batch.
     */
    batchTrashTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            let transactionPayloads = [];
            transactions.forEach(tx => transactionPayloads.push(tx.wrapped));
            yield TransactionService.trashTransactionsBatch(this.getId(), transactionPayloads);
        });
    }
    /**
     * Trigger [Balances Audit](https://help.bkper.com/en/articles/4412038-balances-audit) async process.
     */
    audit() {
        BookService.audit(this.getId());
    }
    /**
     * Gets the existing [[Integrations]] in the Book.
     *
     * @returns The existing Integration objects
     */
    getIntegrations() {
        return __awaiter(this, void 0, void 0, function* () {
            const integrationsPlain = yield IntegrationService.listIntegrations(this.getId());
            const integrations = integrationsPlain.map(i => new Integration_1.Integration(i));
            return integrations;
        });
    }
    /**
     * Creates a new [[Integration]] in the Book.
     *
     * @param integration - The Integration object or wrapped plain json
     *
     * @returns The created Integration object
     */
    createIntegration(integration) {
        return __awaiter(this, void 0, void 0, function* () {
            if (integration instanceof Integration_1.Integration) {
                integration = yield IntegrationService.createIntegration(this.getId(), integration.json());
            }
            else {
                integration = yield IntegrationService.createIntegration(this.getId(), integration);
            }
            return new Integration_1.Integration(integration);
        });
    }
    /**
     * Updates an existing [[Integration]] in the Book.
     *
     * @param integration - The Integration wrapped plain json
     *
     * @returns The updated Integration object
     */
    updateIntegration(integration) {
        return __awaiter(this, void 0, void 0, function* () {
            if (integration instanceof Integration_1.Integration) {
                integration = yield IntegrationService.updateIntegration(this.getId(), integration.json());
            }
            else {
                integration = yield IntegrationService.updateIntegration(this.getId(), integration);
            }
            return new Integration_1.Integration(integration);
        });
    }
    /**
     * Resumes a transaction iteration using a continuation token from a previous iterator.
     *
     * @param continuationToken - continuation token from a previous transaction iterator
     *
     * @returns a collection of transactions that remained in a previous iterator when the continuation token was generated
     */
    continueTransactionIterator(query, continuationToken) {
        var transactionIterator = new TransactionIterator_1.TransactionIterator(this, query);
        transactionIterator.setContinuationToken(continuationToken);
        return transactionIterator;
    }
    configureTransactions_(transactions) {
        for (var i = 0; i < transactions.length; i++) {
            this.configureTransaction_(transactions[i]);
        }
        return transactions;
    }
    /** @internal */
    configureTransaction_(transaction) {
        transaction.book = this;
        return transaction;
    }
    /**
     * Instantiate a new [[Transaction]]
     *
     * Example:
     *
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * book.newTransaction()
     *  .setDate('2013-01-25')
     *  .setDescription("Filling tank of my truck")
     *  .from('Credit Card')
     *  .to('Gas')
     *  .setAmount(126.50)
     *  .create();
     *
     * ```
     *
     */
    newTransaction() {
        let transaction = Utils.wrapObject(new Transaction_1.Transaction(), {});
        this.configureTransaction_(transaction);
        return transaction;
    }
    /**
     * Instantiate a new [[Account]]
     *
     * Example:
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * book.newAccount()
     *  .setName('Some New Account')
     *  .setType('INCOMING')
     *  .addGroup('Revenue').addGroup('Salary')
     *  .setProperties({prop_a: 'A', prop_b: 'B'})
     *  .create();
     * ```
     */
    newAccount() {
        let account = Utils.wrapObject(new Account_1.Account(), {});
        account.setArchived(false);
        account.book = this;
        return account;
    }
    /**
     * Instantiate a new [[Group]]
     *
     * Example:
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * book.newGroup()
     *  .setName('Some New Group')
     *  .setProperty('key', 'value')
     *  .create();
     * ```
     */
    newGroup() {
        let group = Utils.wrapObject(new Group_1.Group(), {});
        group.book = this;
        return group;
    }
    /**
     * Gets an [[Account]] object
     *
     * @param idOrName - The id or name of the Account
     *
     * @returns The matching Account object
     */
    getAccount(idOrName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (idOrName == null) {
                return null;
            }
            idOrName = idOrName + '';
            const accountPlain = yield AccountService.getAccount(this.getId(), idOrName);
            if (!accountPlain) {
                return null;
            }
            const account = Utils.wrapObject(new Account_1.Account(), accountPlain);
            account.book = this;
            return account;
        });
    }
    /** @internal */
    updateGroupCache(group) {
        group.book = this;
        if (this.idGroupMap) {
            this.idGroupMap.set(group.getId(), group);
            this.nameGroupMap.set(utils_1.normalizeName(group.getName()), group);
        }
    }
    removeGroupCache(group) {
        if (this.idGroupMap) {
            this.idGroupMap.delete(group.getId());
            this.nameGroupMap.delete(utils_1.normalizeName(group.getName()));
        }
    }
    /**
     * Gets a [[Group]] object
     *
     * @param idOrName - The id or name of the Group
     *
     * @returns The matching Group object
     */
    getGroup(idOrName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (idOrName == null) {
                return null;
            }
            idOrName = idOrName + '';
            if (this.idGroupMap) {
                let group = this.idGroupMap.get(idOrName);
                if (!group) {
                    group = this.nameGroupMap.get(utils_1.normalizeName(idOrName));
                }
                if (group) {
                    return group;
                }
            }
            const groupPlain = yield GroupService.getGroup(this.getId(), idOrName);
            if (!groupPlain) {
                return null;
            }
            let group = Utils.wrapObject(new Group_1.Group(), groupPlain);
            this.updateGroupCache(group);
            return group;
        });
    }
    /**
     * Gets all [[Groups]] of this Book
     */
    getGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.idGroupMap) {
                return Array.from(this.idGroupMap.values());
            }
            let groups = yield GroupService.getGroups(this.getId());
            let groupsObj = Utils.wrapObjects(new Group_1.Group(), groups);
            this.idGroupMap = new Map();
            this.nameGroupMap = new Map();
            for (var i = 0; i < groupsObj.length; i++) {
                var group = groupsObj[i];
                this.updateGroupCache(group);
            }
            return groupsObj;
        });
    }
    /**
     * Get the [[Groups]] of a given account.
     */
    getGroupsByAccount(accountIdOrName) {
        return __awaiter(this, void 0, void 0, function* () {
            let groups = yield GroupService.getGroupsByAccountId(this.getId(), accountIdOrName);
            let groupsObj = Utils.wrapObjects(new Group_1.Group(), groups);
            for (const group of groupsObj) {
                group.book = this;
            }
            return groupsObj;
        });
    }
    /**
     * Get Book transactions based on a query.
     *
     * See [Query Guide](https://help.bkper.com/en/articles/2569178-search-query-guide) to learn more
     *
     * @param query - The query string.
     *
     * @returns The Transactions result as an iterator.
     *
     * Example:
     *
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * var transactions = book.getTransactions("account:CreditCard after:28/01/2013 before:29/01/2013");
     *
     * while (transactions.hasNext()) {
     *  var transaction = transactions.next();
     *  Logger.log(transaction.getDescription());
     * }
     * ```
     */
    getTransactions(query) {
        return new TransactionIterator_1.TransactionIterator(this, query);
    }
    /**
     * Retrieve a transaction by id
     */
    getTransaction(id) {
        return __awaiter(this, void 0, void 0, function* () {
            let wrapped = yield TransactionService.getTransaction(this.getId(), id);
            if (!wrapped) {
                return null;
            }
            let transaction = Utils.wrapObject(new Transaction_1.Transaction(), wrapped);
            this.configureTransaction_(transaction);
            return transaction;
        });
    }
    /**
     * Instantiate a new [[BkperFile]]
     *
     * Example:
     * ```js
     * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
     *
     * book.newFile()
     *  .setBlob(UrlFetchApp.fetch('https://bkper.com/images/index/integrations4.png').getBlob())
     *  .create();
     * ```
     */
    newFile() {
        let file = Utils.wrapObject(new File_1.File(), {});
        file.book = this;
        return file;
    }
    /**
     * Retrieve a file by id
     */
    getFile(id) {
        return __awaiter(this, void 0, void 0, function* () {
            let wrapped = yield FileService.getFile(this.getId(), id);
            let file = Utils.wrapObject(new File_1.File(), wrapped);
            return file;
        });
    }
    /**
     * Perform update Book, applying pending changes.
     */
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            this.wrapped = yield BookService.updateBook(this.getId(), this.wrapped);
            return this;
        });
    }
}
exports.Book = Book;
//# sourceMappingURL=Book.js.map