"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionIterator = void 0;
const TransactionPage_1 = require("./TransactionPage");
/**
 *
 * An iterator that allows scripts to iterate over a potentially large collection of transactions.
 *
 * Example:
 *
 * ```js
 * var book = BkperApp.getBook("agtzfmJrcGVyLWhyZHITCxIGTGVkZ2VyGICAgIDggqALDA");
 *
 * var transactionIterator = book.getTransactions("account:CreditCard after:28/01/2013 before:29/01/2013");
 *
 * while (transactionIterator.hasNext()) {
 *  var transaction = transactions.next();
 *  Logger.log(transaction.getDescription());
 * }
 * ```
 *
 * @public
 */
class TransactionIterator {
    /** @internal */
    constructor(book, query) {
        this.book = book;
        this.query = query;
        if (this.query == null) {
            this.query = "";
        }
        this.currentPage = null;
        this.nextPage = null;
        this.lastCursor = null;
    }
    /**
     * Gets the Book that originate the iterator
     */
    getBook() {
        return this.book;
    }
    /**
     * Gets a token that can be used to resume this iteration at a later time.
     *
     * This method is useful if processing an iterator in one execution would exceed the maximum execution time.
     *
     * Continuation tokens are generally valid short period of time.
     */
    getContinuationToken() {
        if (this.currentPage == null) {
            return null;
        }
        var cursor = this.lastCursor;
        if (cursor == null) {
            cursor = "null";
        }
        var continuationToken = cursor + "_bkperpageindex_" + this.currentPage.getIndex();
        return continuationToken;
    }
    /**
     * Sets a continuation token from previous paused iteration
     */
    setContinuationToken(continuationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (continuationToken == null) {
                return;
            }
            var cursorIndexArray = continuationToken.split("_bkperpageindex_");
            if (cursorIndexArray.length != 2) {
                return;
            }
            var cursor = cursorIndexArray[0];
            var index = cursorIndexArray[1];
            if ("null" != cursor) {
                this.lastCursor = cursor;
            }
            let indexNum = new Number(index).valueOf();
            this.currentPage = yield new TransactionPage_1.TransactionPage().init(this.book, this.query, this.lastCursor);
            this.currentPage.setIndex(indexNum);
        });
    }
    /**
     * Determines whether calling next() will return a transaction.
     */
    hasNext() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentPage == null) {
                this.currentPage = yield new TransactionPage_1.TransactionPage().init(this.book, this.query, this.lastCursor);
            }
            if (this.currentPage.hasNext()) {
                return true;
            }
            else if (!this.currentPage.hasReachEnd()) {
                this.lastCursor = this.currentPage.getCursor();
                if (this.nextPage == null) {
                    this.nextPage = yield new TransactionPage_1.TransactionPage().init(this.book, this.query, this.lastCursor);
                }
                return this.nextPage.hasNext();
            }
            else {
                return false;
            }
        });
    }
    /**
     * Gets the next transaction in the collection of transactions.
     */
    next() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentPage == null) {
                this.currentPage = yield new TransactionPage_1.TransactionPage().init(this.book, this.query, this.lastCursor);
            }
            if (this.currentPage.hasNext()) {
                return this.currentPage.next();
            }
            else if (!this.currentPage.hasReachEnd()) {
                this.lastCursor = this.currentPage.getCursor();
                if (this.nextPage != null) {
                    this.currentPage = this.nextPage;
                    this.nextPage = null;
                }
                else {
                    this.currentPage = yield new TransactionPage_1.TransactionPage().init(this.book, this.query, this.lastCursor);
                }
                return this.currentPage.next();
            }
            else {
                return null;
            }
        });
    }
    /**
     * @returns The account, when filtering by a single account.
     */
    getAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentPage == null) {
                this.currentPage = yield new TransactionPage_1.TransactionPage().init(this.book, this.query, this.lastCursor);
            }
            return this.currentPage.getAccount();
        });
    }
}
exports.TransactionIterator = TransactionIterator;
//# sourceMappingURL=TransactionIterator.js.map