"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const File_1 = require("./File");
const Account_1 = require("./Account");
const TransactionService = __importStar(require("../service/transaction-service"));
const Utils = __importStar(require("../utils"));
const Amount_1 = require("./Amount");
/**
 *
 * This class defines a Transaction between [credit and debit](http://en.wikipedia.org/wiki/Debits_and_credits) [[Accounts]].
 *
 * A Transaction is the main entity on the [Double Entry](http://en.wikipedia.org/wiki/Double-entry_bookkeeping_system) [Bookkeeping](http://en.wikipedia.org/wiki/Bookkeeping) system.
 *
 * @public
 */
class Transaction {
    /**
     * @returns The id of the Transaction.
     */
    getId() {
        return this.wrapped.id;
    }
    /**
     * @returns The id of the agent that created this transaction
     */
    getAgentId() {
        return this.wrapped.agentId;
    }
    /**
     * Remote ids are used to avoid duplication.
     *
     * @returns The remote ids of the Transaction.
     */
    getRemoteIds() {
        return this.wrapped.remoteIds;
    }
    /**
     * Add a remote id to the Transaction.
     *
     * @param remoteId - The remote id to add.
     *
     * @returns This Transaction, for chainning.
     */
    addRemoteId(remoteId) {
        if (this.wrapped.remoteIds == null) {
            this.wrapped.remoteIds = [];
        }
        if (remoteId) {
            this.wrapped.remoteIds.push(remoteId);
        }
        return this;
    }
    /**
     * @returns True if transaction was already posted to the accounts. False if is still a Draft.
     */
    isPosted() {
        return this.wrapped.posted;
    }
    /**
     * @returns True if transaction is checked.
     */
    isChecked() {
        return this.wrapped.checked;
    }
    /**
     * @returns True if transaction is in trash.
     */
    isTrashed() {
        return this.wrapped.trashed;
    }
    /**
     * @returns All #hashtags used on the transaction.
     */
    getTags() {
        return this.wrapped.tags;
    }
    /**
     * @returns All urls of the transaction.
     */
    getUrls() {
        return this.wrapped.urls;
    }
    /**
     * Sets the Transaction urls. Url starts with https://
     *
     * @param urls - The urls array.
     *
     * @returns This Transaction, for chainning.
     */
    setUrls(urls) {
        this.wrapped.urls = null;
        if (urls) {
            urls.forEach(url => {
                this.addUrl(url);
            });
        }
        return this;
    }
    /**
     * Add a url to the Transaction. Url starts with https://
     *
     * @param url - The url to add.
     *
     * @returns This Transaction, for chainning.
     */
    addUrl(url) {
        if (this.wrapped.urls == null) {
            this.wrapped.urls = [];
        }
        if (url) {
            this.wrapped.urls.push(url);
        }
        return this;
    }
    /**
     * @returns The files attached to the transaction.
     */
    getFiles() {
        if (this.wrapped.files && this.wrapped.files.length > 0) {
            const files = Utils.wrapObjects(new File_1.File(), this.wrapped.files);
            if (files != null) {
                for (const file of files) {
                    file.book = this.book;
                }
            }
            return files;
        }
        else {
            return [];
        }
    }
    /**
     *
     * Adds a file attachment to the Transaction.
     *
     * Files not previously created in the Book will be automatically created.
     *
     * @param file - The file to add
     *
     * @returns This Transaction, for chainning.
     */
    addFile(file) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wrapped.files == null) {
                this.wrapped.files = [];
            }
            //Make sure file is already created
            if (file.getId() == null || file.book.getId() != this.book.getId()) {
                file.book = this.book;
                file = yield file.create();
            }
            this.wrapped.files.push(file.wrapped);
            return this;
        });
    }
    /**
     * Check if the transaction has the specified tag.
     */
    hasTag(tag) {
        var tags = this.getTags();
        for (var i = 0; i < tags.length; i++) {
            if (tags[i] == tag) {
                return true;
            }
        }
        return false;
    }
    /**
     * Gets the custom properties stored in this Transaction.
     */
    getProperties() {
        return this.wrapped.properties != null ? Object.assign({}, this.wrapped.properties) : {};
    }
    /**
     * Sets the custom properties of the Transaction
     *
     * @param properties - Object with key/value pair properties
     *
     * @returns This Transaction, for chainning.
     */
    setProperties(properties) {
        this.wrapped.properties = Object.assign({}, properties);
        return this;
    }
    /**
     * Gets the property value for given keys. First property found will be retrieved
     *
     * @param keys - The property key
     */
    getProperty(...keys) {
        for (let index = 0; index < keys.length; index++) {
            const key = keys[index];
            let value = this.wrapped.properties != null ? this.wrapped.properties[key] : null;
            if (value != null && value.trim() != '') {
                return value;
            }
        }
        return null;
    }
    /**
    * Gets the custom properties keys stored in this Transaction.
    */
    getPropertyKeys() {
        let properties = this.getProperties();
        let propertyKeys = [];
        if (properties) {
            for (var key in properties) {
                if (Object.prototype.hasOwnProperty.call(properties, key)) {
                    propertyKeys.push(key);
                }
            }
        }
        propertyKeys = propertyKeys.sort();
        return propertyKeys;
    }
    /**
     * Sets a custom property in the Transaction.
     *
     * @param key - The property key
     * @param value - The property value
     *
     * @returns This Transaction, for chainning.
     */
    setProperty(key, value) {
        if (key == null || key.trim() == '') {
            return this;
        }
        if (this.wrapped.properties == null) {
            this.wrapped.properties = {};
        }
        this.wrapped.properties[key] = value;
        return this;
    }
    /**
     * Delete a custom property
     *
     * @param key - The property key
     *
     * @returns This Transaction, for chainning.
     */
    deleteProperty(key) {
        this.setProperty(key, null);
        return this;
    }
    //ORIGIN ACCOUNT
    /**
     * @returns The credit account. The same as origin account.
     */
    getCreditAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.wrapped.creditAccount) {
                this.creditAccount = null;
                return null;
            }
            if (this.creditAccount == null) {
                this.creditAccount = yield this.book.getAccount(this.wrapped.creditAccount.id);
            }
            return this.creditAccount;
        });
    }
    /**
     * @returns The credit account name.
     */
    getCreditAccountName() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.getCreditAccount()) != null) {
                return (yield this.getCreditAccount()).getName();
            }
            else {
                return "";
            }
        });
    }
    /**
     *
     * Sets the credit/origin Account of the Transaction. Same as from().
     *
     * @param account - Account id, name or object.
     *
     * @returns This Transaction, for chainning.
     */
    setCreditAccount(account) {
        if (account != null && account.getId() != null) {
            this.wrapped.creditAccount = account.wrapped;
            this.creditAccount = account;
        }
        return this;
    }
    /**
     *
     * Sets the credit/origin Account of the Transaction. Same as setCreditAccount().
     *
     * @param account - Account id, name or object.
     *
     * @returns This Transaction, for chainning.
     */
    from(account) {
        return this.setCreditAccount(account);
    }
    //DESTINATION ACCOUNT
    /**
     * @returns The debit account. The same as destination account.
     *
     */
    getDebitAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.wrapped.debitAccount) {
                this.debitAccount = null;
                return null;
            }
            if (this.debitAccount == null) {
                this.debitAccount = yield this.book.getAccount(this.wrapped.debitAccount.id);
            }
            return this.debitAccount;
        });
    }
    /**
     * @returns The debit account name.
     */
    getDebitAccountName() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.getDebitAccount()) != null) {
                return (yield this.getDebitAccount()).getName();
            }
            else {
                return "";
            }
        });
    }
    /**
     *
     * Sets the debit/origin Account of the Transaction. Same as to().
     *
     * @param account - Account id, name or object.
     *
     * @returns This Transaction, for chainning.
     */
    setDebitAccount(account) {
        if (account != null && account.getId() != null) {
            this.wrapped.debitAccount = account.wrapped;
            this.debitAccount = account;
        }
        return this;
    }
    /**
     *
     * Sets the debit/origin Account of the Transaction. Same as setDebitAccount().
     *
     * @param account - Account id, name or object.
     *
     * @returns This Transaction, for chainning.
     */
    to(account) {
        return this.setDebitAccount(account);
    }
    //AMOUNT
    /**
     * @returns The amount of the transaction.
     */
    getAmount() {
        return this.wrapped.amount != null && this.wrapped.amount.trim() != '' ? new Amount_1.Amount(this.wrapped.amount) : null;
    }
    /**
     *
     * Sets the amount of the Transaction.
     *
     * @returns This Transaction, for chainning.
     */
    setAmount(amount) {
        if (typeof amount == "string") {
            amount = Utils.parseValue(amount, this.book.getDecimalSeparator()) + '';
            this.wrapped.amount = amount.toString();
            return this;
        }
        amount = new Amount_1.Amount(amount);
        if (amount.eq(0)) {
            this.wrapped.amount = null;
            return this;
        }
        this.wrapped.amount = amount.abs().toString();
        return this;
    }
    /**
     * Get the absolute amount of this transaction if the given account is at the credit side, else null.
     *
     * @param account - The account object, id or name.
     */
    getCreditAmount(account) {
        return __awaiter(this, void 0, void 0, function* () {
            let accountObject = yield this.getAccount_(account);
            if (this.isCredit(accountObject)) {
                return this.getAmount();
            }
            return null;
        });
    }
    /**
     * Gets the absolute amount of this transaction if the given account is at the debit side, else null.
     *
     * @param account - The account object, id or name.
     */
    getDebitAmount(account) {
        return __awaiter(this, void 0, void 0, function* () {
            let accountObject = yield this.getAccount_(account);
            if (this.isDebit(accountObject)) {
                return this.getAmount();
            }
            return null;
        });
    }
    /**
     * Gets the [[Account]] at the other side of the transaction given the one in one side.
     *
     * @param account - The account object, id or name.
     */
    getOtherAccount(account) {
        return __awaiter(this, void 0, void 0, function* () {
            let accountObject = yield this.getAccount_(account);
            if (this.isCredit(accountObject)) {
                return yield this.getDebitAccount();
            }
            if (this.isDebit(accountObject)) {
                return yield this.getCreditAccount();
            }
            return null;
        });
    }
    /**
     *
     * The account name at the other side of the transaction given the one in one side.
     *
     * @param account - The account object, id or name.
     */
    getOtherAccountName(account) {
        return __awaiter(this, void 0, void 0, function* () {
            var otherAccount = yield this.getOtherAccount(account);
            if (otherAccount != null) {
                return otherAccount.getName();
            }
            else {
                return "";
            }
        });
    }
    /**
     *
     * Tell if the given account is credit on the transaction
     *
     * @param account - The account object
     */
    isCredit(account) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getCreditAccount()) != null && account != null && (yield this.getCreditAccount()).getNormalizedName() == account.getNormalizedName();
        });
    }
    /**
     *
     * Tell if the given account is debit on the transaction
     *
     * @param account - The account object
     */
    isDebit(account) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getDebitAccount()) != null && account != null && (yield this.getDebitAccount()).getNormalizedName() == account.getNormalizedName();
        });
    }
    /** @internal */
    getAccount_(account) {
        return __awaiter(this, void 0, void 0, function* () {
            if (account == null || account instanceof Account_1.Account) {
                return account;
            }
            return yield this.book.getAccount(account);
        });
    }
    //DESCRIPTION
    /**
     * @returns The description of this transaction.
     */
    getDescription() {
        if (this.wrapped.description == null) {
            return "";
        }
        return this.wrapped.description;
    }
    /**
     *
     * Sets the description of the Transaction.
     *
     * @returns This Transaction, for chainning.
     */
    setDescription(description) {
        this.wrapped.description = description;
        return this;
    }
    //DATE
    /**
     * @returns The Transaction date, in ISO format yyyy-MM-dd.
     */
    getDate() {
        return this.wrapped.date;
    }
    /**
     *
     * Sets the date of the Transaction.
     *
     * @returns This Transaction, for chainning
     */
    setDate(date) {
        if (typeof date == "string") {
            if (date.indexOf('/') > 0) {
                let dateObject = Utils.parseDate(date, this.book.getDatePattern(), this.book.getTimeZone());
                this.wrapped.date = Utils.formatDateISO(dateObject, this.book.getTimeZone());
            }
            else if (date.indexOf('-')) {
                this.wrapped.date = date;
            }
        }
        else if (Object.prototype.toString.call(date) === '[object Date]') {
            this.wrapped.date = Utils.formatDateISO(date, this.book.getTimeZone());
        }
        return this;
    }
    /**
     * @returns The Transaction Date object, on the time zone of the [[Book]].
     */
    getDateObject() {
        return Utils.convertValueToDate(this.getDateValue(), this.book.getTimeZoneOffset());
    }
    /**
     * @returns The Transaction date number, in format YYYYMMDD.
     */
    getDateValue() {
        return this.wrapped.dateValue;
    }
    /**
     * @returns The Transaction date, formatted on the date pattern of the [[Book]].
     */
    getDateFormatted() {
        return this.wrapped.dateFormatted;
    }
    /**
     * @returns The date the transaction was created.
     */
    getCreatedAt() {
        return new Date(new Number(this.wrapped.createdAt).valueOf());
    }
    /**
     * @returns The date the transaction was created, formatted according to the date pattern of [[Book]].
     */
    getCreatedAtFormatted() {
        return Utils.formatDate(this.getCreatedAt(), this.book.getTimeZone(), this.book.getDatePattern() + " HH:mm:ss");
    }
    //EVOLVED BALANCES
    /** @internal */
    getCaEvolvedBalance_() {
        return this.wrapped.creditAccount != null && this.wrapped.creditAccount.balance != null ? new Amount_1.Amount(this.wrapped.creditAccount.balance) : null;
    }
    /** @internal */
    getDaEvolvedBalance_() {
        return this.wrapped.debitAccount != null && this.wrapped.debitAccount.balance != null ? new Amount_1.Amount(this.wrapped.debitAccount.balance) : null;
    }
    /**
     * Gets the balance that the [[Account]] has at that day, when listing transactions of that Account.
     *
     * Evolved balances is returned when searching for transactions of a permanent [[Account]].
     *
     * Only comes with the last posted transaction of the day.
     *
     * @param raw - True to get the raw balance, no matter the credit nature of the [[Account]].
     */
    getAccountBalance(raw) {
        return __awaiter(this, void 0, void 0, function* () {
            var accountBalance = this.getCaEvolvedBalance_();
            var isCa = true;
            if (accountBalance == null) {
                accountBalance = this.getDaEvolvedBalance_();
                isCa = false;
            }
            if (accountBalance != null) {
                if (!raw) {
                    var account = isCa ? yield this.getCreditAccount() : yield this.getDebitAccount();
                    accountBalance = Utils.getRepresentativeValue(accountBalance, account.isCredit());
                }
                return Utils.round(accountBalance, this.book.getFractionDigits());
            }
            else {
                return null;
            }
        });
    }
    /**
     * Perform create new draft transaction.
     */
    create() {
        return __awaiter(this, void 0, void 0, function* () {
            let operation = yield TransactionService.createTransaction(this.book.getId(), this.wrapped);
            this.wrapped = operation.transaction;
            return this;
        });
    }
    /**
     * Upddate transaction, applying pending changes.
     */
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            let operation = yield TransactionService.updateTransaction(this.book.getId(), this.wrapped);
            this.wrapped = operation.transaction;
            return this;
        });
    }
    /**
     * Perform check transaction.
     */
    check() {
        return __awaiter(this, void 0, void 0, function* () {
            let operation = yield TransactionService.checkTransaction(this.book.getId(), this.wrapped);
            this.wrapped.checked = operation.transaction.checked;
            return this;
        });
    }
    /**
     * Perform uncheck transaction.
     */
    uncheck() {
        return __awaiter(this, void 0, void 0, function* () {
            let operation = yield TransactionService.uncheckTransaction(this.book.getId(), this.wrapped);
            this.wrapped.checked = operation.transaction.checked;
            return this;
        });
    }
    /**
     * Perform post transaction, changing credit and debit [[Account]] balances.
     */
    post() {
        return __awaiter(this, void 0, void 0, function* () {
            let operation = yield TransactionService.postTransaction(this.book.getId(), this.wrapped);
            this.wrapped = operation.transaction;
            return this;
        });
    }
    /**
     * Remove the transaction, sending to trash.
     */
    remove() {
        return __awaiter(this, void 0, void 0, function* () {
            let operation = yield TransactionService.removeTransaction(this.book.getId(), this.wrapped);
            this.wrapped.trashed = operation.transaction.trashed;
            return this;
        });
    }
    /**
     * Restore the transaction from trash.
     */
    restore() {
        return __awaiter(this, void 0, void 0, function* () {
            let operation = yield TransactionService.restoreTransaction(this.book.getId(), this.wrapped);
            this.wrapped.trashed = operation.transaction.trashed;
            return this;
        });
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=Transaction.js.map