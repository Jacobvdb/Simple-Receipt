"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const AccountService = __importStar(require("../service/account-service"));
const GroupService = __importStar(require("../service/group-service"));
const Group_1 = require("./Group");
const utils_1 = require("../utils");
const Amount_1 = require("./Amount");
const Utils = __importStar(require("../utils"));
/**
 *
 * This class defines an [Account](https://en.wikipedia.org/wiki/Account_(bookkeeping)) of a [[Book]].
 *
 * It mantains a balance of all amount [credited and debited](http://en.wikipedia.org/wiki/Debits_and_credits) in it by [[Transactions]].
 *
 * An Account can be grouped by [[Groups]].
 *
 * @public
 */
class Account {
    /**
     *
     * @returns The wrapped plain json object
     */
    json() {
        return this.wrapped;
    }
    /**
     * Gets the account internal id.
     */
    getId() {
        return this.wrapped.id;
    }
    /**
     * Gets the account name.
     */
    getName() {
        return this.wrapped.name;
    }
    /**
     *
     * Sets the name of the Account.
     *
     * @returns This Account, for chainning.
     */
    setName(name) {
        this.wrapped.name = name;
        return this;
    }
    /**
     * @returns The name of this account without spaces or special characters.
     */
    getNormalizedName() {
        if (this.wrapped.normalizedName) {
            return this.wrapped.normalizedName;
        }
        else {
            return utils_1.normalizeText(this.getName());
        }
    }
    /**
     * @returns The type for of this account.
     */
    getType() {
        return this.wrapped.type;
    }
    /**
     *
     * Sets the type of the Account.
     *
     * @returns This Account, for chainning
     */
    setType(type) {
        this.wrapped.type = type;
        return this;
    }
    /**
     * Gets the custom properties stored in this Account.
     */
    getProperties() {
        return this.wrapped.properties != null ? Object.assign({}, this.wrapped.properties) : {};
    }
    /**
     * Sets the custom properties of the Account
     *
     * @param properties - Object with key/value pair properties
     *
     * @returns This Account, for chainning.
     */
    setProperties(properties) {
        this.wrapped.properties = Object.assign({}, properties);
        return this;
    }
    /**
     * Gets the property value for given keys. First property found will be retrieved
     *
     * @param keys - The property key
     */
    getProperty(...keys) {
        for (let index = 0; index < keys.length; index++) {
            const key = keys[index];
            let value = this.wrapped.properties != null ? this.wrapped.properties[key] : null;
            if (value != null && value.trim() != '') {
                return value;
            }
        }
        return null;
    }
    /**
     * Sets a custom property in the Account.
     *
     * @param key - The property key
     * @param value - The property value
     *
     * @returns This Account, for chainning.
     */
    setProperty(key, value) {
        if (key == null || key.trim() == '') {
            return this;
        }
        if (this.wrapped.properties == null) {
            this.wrapped.properties = {};
        }
        this.wrapped.properties[key] = value;
        return this;
    }
    /**
     * Delete a custom property
     *
     * @param key - The property key
     *
     * @returns This Account, for chainning.
     */
    deleteProperty(key) {
        this.setProperty(key, null);
        return this;
    }
    /**
     * Gets the balance based on credit nature of this Account.
     * @deprecated Use `Book.getBalancesReport` instead.
     * @returns The balance of this account.
     */
    getBalance() {
        var balance = new Amount_1.Amount('0');
        if (this.wrapped.balance != null) {
            balance = utils_1.round(this.wrapped.balance, this.book.getFractionDigits());
        }
        return balance;
    }
    /**
     * Gets the raw balance, no matter credit nature of this Account.
     * @deprecated Use `Book.getBalancesReport` instead.
     * @returns The balance of this account.
     */
    getBalanceRaw() {
        var balance = new Amount_1.Amount('0');
        if (this.wrapped.balance != null) {
            balance = utils_1.round(this.wrapped.balance, this.book.getFractionDigits());
        }
        return balance;
    }
    /**
     * Tell if this account is archived.
     */
    isArchived() {
        return this.wrapped.archived;
    }
    /**
     * Set account archived/unarchived.
     *
     * @returns This Account, for chainning.
     */
    setArchived(archived) {
        this.wrapped.archived = archived;
        return this;
    }
    /**
     * Tell if the Account has any transaction already posted.
     *
     * Accounts with transaction posted, even with zero balance, can only be archived.
     */
    hasTransactionPosted() {
        return this.wrapped.hasTransactionPosted;
    }
    /**
     *
     * Tell if the account is permanent.
     *
     * Permanent Accounts are the ones which final balance is relevant and keep its balances over time.
     *
     * They are also called [Real Accounts](http://en.wikipedia.org/wiki/Account_(accountancy)#Based_on_periodicity_of_flow)
     *
     * Usually represents assets or tangibles, capable of being perceived by the senses or the mind, like bank accounts, money, debts and so on.
     *
     * @returns True if its a permanent Account
     */
    isPermanent() {
        return this.wrapped.permanent;
    }
    /**
     * Tell if the account has a Credit nature or Debit otherwise
     *
     * Credit accounts are just for representation purposes. It increase or decrease the absolute balance. It doesn't affect the overall balance or the behavior of the system.
     *
     * The absolute balance of credit accounts increase when it participate as a credit/origin in a transaction. Its usually for Accounts that increase the balance of the assets, like revenue accounts.
     *
     * ```
     *         Crediting a credit
     *   Thus ---------------------> account increases its absolute balance
     *         Debiting a debit
     *
     *
     *         Debiting a credit
     *   Thus ---------------------> account decreases its absolute balance
     *         Crediting a debit
     * ```
     *
     * As a rule of thumb, and for simple understanding, almost all accounts are Debit nature (NOT credit), except the ones that "offers" amount for the books, like revenue accounts.
     */
    isCredit() {
        return this.wrapped.credit;
    }
    /**
     * Get the [[Groups]] of this account.
     */
    getGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            let groups = yield GroupService.getGroupsByAccountId(this.book.getId(), this.getId());
            let groupsObj = Utils.wrapObjects(new Group_1.Group(), groups);
            for (const group of groupsObj) {
                group.book = this.book;
            }
            return groupsObj;
        });
    }
    /**
     * Sets the groups of the Account.
     *
     * @returns This Account, for chainning.
     */
    setGroups(groups) {
        this.wrapped.groups = null;
        if (groups != null) {
            groups.forEach(group => this.addGroup(group));
        }
        return this;
    }
    /**
     * Add a group to the Account.
     *
     * @returns This Account, for chainning.
     */
    addGroup(group) {
        if (this.wrapped.groups == null) {
            this.wrapped.groups = [];
        }
        if (group instanceof Group_1.Group) {
            this.wrapped.groups.push(group.json());
        }
        else {
            this.wrapped.groups.push(group);
        }
        return this;
    }
    /**
     * Remove a group from the Account.
     */
    removeGroup(group) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wrapped.groups != null) {
                let groupObject = null;
                if (group instanceof Group_1.Group) {
                    groupObject = group;
                }
                else if (typeof group == "string") {
                    groupObject = yield this.book.getGroup(group);
                }
                if (groupObject) {
                    for (let i = 0; i < this.wrapped.groups.length; i++) {
                        const groupId = this.wrapped.groups[i];
                        if (groupId == groupObject.getId()) {
                            this.wrapped.groups.splice(i, 1);
                        }
                    }
                }
            }
            return this;
        });
    }
    /**
     * Tell if this account is in the [[Group]]
     *
     * @param  group - The Group name, id or object
     */
    isInGroup(group) {
        return __awaiter(this, void 0, void 0, function* () {
            if (group == null) {
                return false;
            }
            //Group object
            if (group instanceof Group_1.Group) {
                return this.isInGroupObject_(group);
            }
            //id or name
            var foundGroup = yield this.book.getGroup(group);
            if (foundGroup == null) {
                return false;
            }
            return this.isInGroupObject_(foundGroup);
        });
    }
    /** @internal */
    isInGroupObject_(group) {
        if (this.wrapped.groups == null) {
            return false;
        }
        for (var i = 0; i < this.wrapped.groups.length; i++) {
            if (this.wrapped.groups[i] == group.getId()) {
                return true;
            }
        }
        return false;
    }
    /**
     * Perform create new account.
     */
    create() {
        return __awaiter(this, void 0, void 0, function* () {
            this.wrapped = yield AccountService.createAccount(this.book.getId(), this.wrapped);
            return this;
        });
    }
    /**
     * Perform update account, applying pending changes.
     */
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            this.wrapped = yield AccountService.updateAccount(this.book.getId(), this.wrapped);
            return this;
        });
    }
    /**
     * Perform delete account.
     */
    remove() {
        return __awaiter(this, void 0, void 0, function* () {
            this.wrapped = yield AccountService.deleteAccount(this.book.getId(), this.wrapped);
            return this;
        });
    }
}
exports.Account = Account;
//# sourceMappingURL=Account.js.map